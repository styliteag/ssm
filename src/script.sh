#!/usr/bin/env sh

set -eu

# shellcheck disable=SC3040
(set -o pipefail 2> /dev/null) && set -o pipefail

authorized_keys_location=".ssh/authorized_keys"
externaly_managed_keyfile="${HOME}/.ssh/external_managed_keys"
readonly_keyfile="${HOME}/.ssh/readonly_keys"
version="Secure SSH Manager script v0.2-alpha"
keyfile_head="# Auto-generated by Secure SSH Manager. DO NOT EDIT!"

# TODO: Can we assume /tmp is writable?
TMP="/tmp"

# TODO: Read authorized_keys location from sshd config
# Get the location of the authorized keyfile given a username
get_authorized_keys_location() {
  user="$1"
  home=$(getent passwd "${user}" | cut -d: -f6)

  echo "${home}/${authorized_keys_location}"
}

check_keyfile_permissions() {
  keyfile_location="$1"
  if [ -f "${externaly_managed_keyfile}" ]; then    echo "# !read-only"
    echo "# !externaly_managed_keyfile:true"
    echo "# Externaly managed keyfile because ${externaly_managed_keyfile} exists."
  fi
  if [ -f "${readonly_keyfile}" ]; then
    echo "# !readonly_keyfile:true"
    echo "# Readonly keyfile because ${readonly_keyfile} exists."
  fi

  # Check if we are running on pfSense
  if grep -q "pfSense" "/etc/platform" > /dev/null 2>&1; then
    echo "# !externaly_managed_keyfile:true"
    echo "# Externaly managed keyfile because we are running on pfSense."
  fi
  # Check if we are running on TrueNAS Core
  if uname -a | grep -q "TRUENAS" > /dev/null 2>&1; then
    echo "# !externaly_managed_keyfile:true"
    echo "# Externaly managed keyfile because we are running on TrueNAS Core."
  fi
  # Check if we are running on TrueNAS Scale
  if uname -a | grep -q "+truenas " > /dev/null 2>&1; then
    echo "# !externaly_managed_keyfile:true"
    echo "# Externaly managed keyfile because we are running on TrueNAS Scale."
  fi
  # Check if we are running on Sophos UTM
  if [ -f "/etc/product" ] && grep -q "Sophos UTM" "/etc/product" > /dev/null 2>&1; then
    echo "# !externaly_managed_keyfile:true"
    echo "# Externaly managed keyfile because we are running on Sophos UTM."
  fi
}

command="$1"
case "${command}" in
  get_authorized_keyfile)
    user="$2"
    keyfile_location=$(get_authorized_keys_location "${user}")

    if [ ! -e "${keyfile_location}" ]; then
      echo "Couldn't find authorized_keys for this user."
      echo "Tried location: ${keyfile_location}"
      exit 1
    fi

    #check_keyfile_permissions "${keyfile_location}"
    cat "${keyfile_location}" && check_keyfile_permissions "${keyfile_location}"
    exit 0
    ;;
  set_authorized_keyfile)
    user="$2"
    keyfile_location=$(get_authorized_keys_location "${user}")

    if [ -e "${keyfile_location}" ]; then
      file_head=$(head -n1 < "${keyfile_location}")

      if [ "${file_head}" != "${keyfile_head}" ]; then
        # Move keyfile to backup
        mv "${keyfile_location}" "${keyfile_location}.backup"
      fi
    fi

    # Read new authorized_keys from stdin
    printf "%s\n" "${keyfile_head}" > "${keyfile_location}"
    cat - >> "${keyfile_location}"
    exit 0
    ;;
  get_ssh_users)
    # Get all the home directories and user names, remove duplicates
    # Create a temp file to store the home directories we already processed
    echo > "${TMP}/homedirs.$$"
    getent passwd | while IFS=: read -r name _password _uid _gid _gecos home _shell; do
      if [ -e "${home}/${authorized_keys_location}" ]; then
        # Check if the home directory is already in the temp file
        found=0
        while read -r line; do
          if [ "$line" = "$home" ]; then
            found=1
            break
          fi
        done < "${TMP}/homedirs.$$"
        
        if [ "$found" = 0 ]; then
          echo "${name}"
          echo "${home}" >> "${TMP}/homedirs.$$"
        fi
      fi
    done
    rm -f "${TMP}/homedirs.$$"
    exit 0
    ;;
  update)
    newfile="${0}.new"
    cat - > "${newfile}"

    mv "${newfile}" "${0}"
    exit 0
    ;;

  version)
    printf "%s\n" "${version}"
    exit 0
    ;;

  *)
    printf "Command '%s' not found.\n" "${command}"
    exit 2
    ;;
esac
