#!/usr/bin/env sh

set -eu

# shellcheck disable=SC3040
(set -o pipefail 2> /dev/null) && set -o pipefail

authorized_keys_location=".ssh/authorized_keys"
externaly_managed_keyfile="${HOME}/.ssh/external_managed_keys"
readonly_keyfile="${HOME}/.ssh/readonly_keys"
version="Secure SSH Manager script v0.2-alpha"
keyfile_head="# Auto-generated by Secure SSH Manager. DO NOT EDIT!"

cleanup() {
    rm -f "${TMP}/homedirs.$$"
}
trap cleanup EXIT INT TERM

TMP="${TMPDIR:-/tmp}"

print_help() {
    cat << EOF
Secure SSH Manager ${version}

Usage: $(basename "$0") COMMAND [OPTIONS]

Commands:
  get_authorized_keyfile USER    Display authorized keys for specified user
  set_authorized_keyfile USER    Set authorized keys for specified user (read from stdin)
  get_ssh_users                  List all users with SSH access
  update                         Update this script (read from stdin)
  version                        Display version information
EOF
}

have_getent() {
  command -v getent >/dev/null 2>&1
}

do_getent_passwd_all() {
  if have_getent; then
    getent passwd
  else
    cat /etc/passwd
  fi
}

do_getent_passwd() {
  user="$1"
  if have_getent; then
    getent passwd "${user}"
  else
    grep "^${user}:" /etc/passwd
  fi
}

# TODO: Read authorized_keys location from sshd config
# Get the location of the authorized keyfile given a username
get_authorized_keys_location() {
  user="$1"
  home=$(do_getent_passwd "${user}" | cut -d: -f6)
  
  echo "${home}/${authorized_keys_location}"
}

# Check if the system has any conditions that make the keyfile externally managed or readonly
check_keyfile_conditions() {
    conditions=""
    
    # Check for special files
    [ -f "${externaly_managed_keyfile}" ] && conditions="${conditions} readonly because external_file ${externaly_managed_keyfile} exists"
    [ -f "${readonly_keyfile}" ] && conditions="${conditions} readonly because ${readonly_keyfile} exists"
    
    # Check for specific systems
    grep -q "pfSense" "/etc/platform" 2>/dev/null && conditions="${conditions} readonly because product is pfSense"
    uname -a | grep -q "TRUENAS" 2>/dev/null && conditions="${conditions} readonly because product is Truenas Core"
    uname -a | grep -q "+truenas " 2>/dev/null && conditions="${conditions} readonly because product is Truenas Scale"
    [ -f "/etc/product" ] && grep -q "Sophos UTM" "/etc/product" 2>/dev/null && conditions="${conditions} readonly because product is Sophos UTM"
    
    echo "${conditions}"
}

# Output comments for get_authorized_keyfile command
print_keyfile_comments() {
    conditions=$(check_keyfile_conditions)
    if [ -n "${conditions}" ]; then
        printf "# !read-only:true\n"
        printf "# !message:${conditions}\n"
    fi
}

# Check if keyfile modifications should be blocked
is_keyfile_readonly() {
    conditions=$(check_keyfile_conditions)
    if [ -n "${conditions}" ]; then
        return 0
    fi
    return 1
}

handle_get_authorized_keyfile() {
    user="$1"
    keyfile_location=$(get_authorized_keys_location "${user}")

    if [ ! -e "${keyfile_location}" ]; then
        echo "Couldn't find authorized_keys for this user."
        echo "Tried location: ${keyfile_location}"
        exit 1
    fi
    cat "${keyfile_location}" && print_keyfile_comments
    exit 0
}

handle_set_authorized_keyfile() {
    user="$1"
    keyfile_location=$(get_authorized_keys_location "${user}")

    if is_keyfile_readonly; then
        echo "Keyfile is readonly, aborting."
        exit 1
    fi

    if [ -e "${keyfile_location}" ]; then
        file_head=$(head -n1 < "${keyfile_location}")

        if [ "${file_head}" != "${keyfile_head}" ]; then
            mv "${keyfile_location}" "${keyfile_location}.backup"
        fi
    fi

    printf "%s\n" "${keyfile_head}" > "${keyfile_location}"
    cat - >> "${keyfile_location}"
    exit 0
}

handle_get_ssh_users() {
    printf "" > "${TMP}/homedirs.$$"
    
    do_getent_passwd_all | while IFS=: read -r name _password _uid _gid _gecos home _shell; do
            if [ -e "${home}/${authorized_keys_location}" ]; then
                grep "^${home}\$" "${TMP}/homedirs.$$" >/dev/null 2>&1 || echo "${name}"
                echo "${home}" >> "${TMP}/homedirs.$$"
            fi
        done
    rm -f "${TMP}/homedirs.$$"
    exit 0
}

handle_update() {
    newfile="${0}.new"
    cat - > "${newfile}"
    # Can we check if the new file is valid?
    mv "${newfile}" "${0}"
    exit 0
}

handle_version() {
    printf "%s\n" "${version}"
    exit 0
}

#####################################
# Script starts here
#####################################

# Modify the command handling section
if [ $# -eq 0 ]; then
    print_help
    exit 1
fi

command="$1"
shift
case "${command}" in
    get_authorized_keyfile)  handle_get_authorized_keyfile "$@" ;;
    set_authorized_keyfile)  handle_set_authorized_keyfile "$@" ;;
    get_ssh_users)           handle_get_ssh_users ;;
    update)                  handle_update ;;
    version)                 handle_version ;;
    *)
        printf "Command '%s' not found.\n" "${command}"
        exit 2
        ;;
esac
